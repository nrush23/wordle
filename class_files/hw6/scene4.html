<body bgcolor=black>
<center><canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script>

// DATA FOR THE BEZIER CURVED PATH

// _.BX = [ -.5,-.1, .8, .8, .8, -.9, -.5 ];
// _.BY = [ -.1,-.4,-.2, .4, .6,  .2, -.1 ];0

_.BX = [ 5.962653, 5.557679, 5.246935, 4.427547, 4.231332, 3.957428, 3.700778, 3.527545, 2.949061, 2.187283, 1.916405, 0.431758, -0.459171, -1.832646, -4.725449, -3.327681, -2.846948, -0.641367, -0.755947, -0.837475, -1.91669, -4.749329, -5.148104, -6.942525, -7.325772, -8.516395, -10.69049, -6.991712, -6.800927, -3.715278, -3.1815, -3.085954, -0.984637, -1.092647, -1.501243, -2.122267, 0.861706, 1.323289, 2.506027, 3.017921, 3.41459, 6.010425, 6.522319, 6.918988, 8.566551, 8.976544, 9.431212, 9.190415, 9.14864, 9.072442, 5.703508, 5.962653 ];
_.BY = [ 4.650385, 4.651405, 4.999056, 4.79332, 4.744053, 4.679785, 4.6434, 4.618841, 4.638083, 4.637498, 4.63729, 4.627297, 4.71326, 4.845782, 4.984596, 4.845493, 4.797651, 4.710769, 4.578196, 4.483863, 4.464466, 4.578196, 4.594206, 4.828518, 4.845493, 4.898227, 1.691512, 0.050903, -0.03372, 0.001233, 0.0, -0.000221, -0.008813, 0.0, 0.033339, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.50257, 0.951126, 1.448559, 2.107077, 2.608137, 3.522058, 4.483312, 4.650385 ];
_.BZ = [ -0.208223, -0.215029, 3.32467, 3.357878, 3.36583, 3.297317, 2.836778, 2.525923, 0.517979, -0.190809, -0.442844, -0.042246, -0.160965, -0.343984, 1.38826, 3.198316, 3.820846, 3.76988, 2.606519, 1.778734, -0.361032, 0.065689, 0.125763, 2.770259, 2.948208, 3.501038, 4.38697, 2.7666, 2.68302, -0.415637, -0.416465, -0.416613, -0.729298, 0.07372, 3.111483, 6.527402, 0.671975, -0.233784, 0.065533, 0.046633, 0.031986, 0.065533, 0.046633, 0.031986, -0.016189, -0.085838, -0.163076, -0.612176, -0.514291, -0.335753, -0.573871, -0.208223 ];


// ANIMATE ALONG A SPLINE

function Scene() {

// GENERTIC PARAMETRIC SURFACE

let parametric = (f,nu,nv,other) => {
   let V = [];
   for (let j = 0 ; j < nv ; j++) {
      for (let i = 0 ; i <= nu ; i++) {
         V.push(f(i/nu,j/nv,other));
         V.push(f(i/nu,(j+1)/nv,other));
      }
      V.push(f(1,(j+1)/nv,other));
      V.push(f(0,(j+1)/nv,other));
   }
   return V.flat();
}

// PARAMETRIC SPHERE

let sphere = (nu,nv) => parametric((u,v) => {
   let theta = 2 * Math.PI * u;
   let phi = Math.PI * (v - 1/2);
   let cu = Math.cos(theta);
   let su = Math.sin(theta);
   let cv = Math.cos(phi);
   let sv = Math.sin(phi);
   let x = cu * cv, y = su * cv, z = sv;
   return [x,y,z, x,y,z];
},nu,nv);

// EVALUATE A POINT ALONG A BEZIER SPLINE

let evalBezier = (t, BX, BY, BZ) => {
   let nk = (BX.length-1) / 3;

   // MATH TO EVALUATE A POINT ALONG A BEZIER SPLINE

   let M = [ [-1,3,-3,1],[3,-6,3,0],[-3,3,0,0],[1,0,0,0] ];
   let T = (a,t) => a[0]*t*t*t + a[1]*t*t + a[2]*t + a[3];
   let Vi = (V,i,t) => V[i] * T(M[i],t);
   let C = (V,t) => Vi(V,0,t)+Vi(V,1,t)+Vi(V,2,t)+Vi(V,3,t);

   // FIND THE SPLINE SEGMENT AND POSITION IN THE SEGMENT

   let n = nk * t - .001 >> 0;
   let f = nk * t - n;

   // EVAL AND RETURN THE X AND Y COORDINATES OF THE POINT

   return [ C(BX.slice(3*n), f), C(BY.slice(3*n), f), C(BZ.slice(3*n), f) ];
}

mesh = {
   triangle_strip: true,
   data: new Float32Array(sphere(20,10))
};

// GLSL SHADERS

this.vertexShader = `\
#version 300 es
uniform mat4 uMF, uMI;
in  vec3 aPos, aNor;
out vec3 vPos, vNor;
void main() {
   vec4 pos = uMF * vec4(aPos, 1.);
   vec4 nor = vec4(aNor, 0.) * uMI;
   gl_Position = pos * vec4(1.,1.,-.1,1.);
   vPos = pos.xyz;
   vNor = nor.xyz;
}`;

this.fragmentShader = `\
#version 300 es
precision highp float;
in  vec3 vPos, vNor;
out vec4 fragColor;

void main() {
   vec3 nor = normalize(vNor);
   float c = .1 + max(0., dot(vec3(.5),nor));
   fragColor = vec4(c,0.,0., 1.);
}`;

let startTime = Date.now() / 1000;

// ANIMATE ALONG THE PATH AND RENDER THE SHAPE

this.update = () => {
   let time = Date.now() / 1000;
   let p = evalBezier(time/8 % 1, _.BX, _.BY, _.BZ);
   let m = mxm(perspective(0,0,-.5),
           mxm(move(p[0],p[1],0),
	       scale(.05)));
   setUniform('Matrix4fv', 'uMF', false, m);
   setUniform('Matrix4fv', 'uMI', false, inverse(m));
}

}
gl_start(canvas, new Scene());
</script>

